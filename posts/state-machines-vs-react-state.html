<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solving Boolean Hell: A State Machine Approach. Part 1 - Obafemi Joseph</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../post-styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;700&family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="blog-nav">
        <a href="../index.html" class="back-link">‚Üê Back to Home</a>
    </nav>
    
    <article class="blog-post">
        <header class="post-header">
            <h1 class="post-title">Solving Boolean Hell: A State Machine Approach. Part 1</h1>
            <p class="post-date">January 09, 2026</p>
        </header>
        
        <div class="post-content">
            <p>
                If you have ever entered  a codebase and seen a mess of boolean flags, and gone "what the hell is this?", you are not alone.
                This is actually a much more common problem than you might think. With AI usage becoming more prevalent, and the amount of code generated by AI increasing, this problem is only going to get worse.
                What starts out as a convenient way to get something done, quickly, ends up becoming a maintenance nightmare. Using booleans in React is not the problem, infact it is a good thing. However, managing React UI states
                with something so flaky is where the problem lies.
            </p> 
            
            <p>
                To solve this problem, we need to understand why managing React states with booleans is a bad idea. Let us take a look at a simple example:
            </p>
            <pre>

                <code>
                const [isLoading, setIsLoading] = useState(false);
                const [isError, setIsError] = useState(false);
                const [isSuccess, setIsSuccess] = useState(false);
                const [isSubmitting, setIsSubmitting] = useState(false);
                const [isSubmitted, setIsSubmitted] = useState(false);
                const [isTouched, setIsTouched] = useState(false);
                </code>
            </pre>

            <p>
                As you can see, this is a mess already. Infact, the biggest issues are not evident from just a first look. 
                Let us take a look at the biggest issues:
                <ul>
                    <li><strong>State synchronization issues:</strong> Multiple related states can fall out of sync, leading to unexpected UI behavior.</li>
                    <li><strong>Difficult debugging:</strong> When something goes wrong, you need to trace through multiple state updates to understand the current application state.</li>
                    <li><strong>Testing complexity:</strong> Testing all possible combinations of boolean states becomes exponentially more difficult.</li>
                    <li><strong>Maintenance burden:</strong> Adding new validation rules or form fields requires updating multiple state variables and their interdependencies.</li>
                </ul>
            </p>
            

            <h2>The Problem with Boolean Hell</h2>

            <p>
                Say for example, you are building a form, and you want to 
                <ul>
                    <li>Show a loading state</li>
                    <li>Show an error state</li>
                    <li>Show a success state</li>
                    <li>Show a submitting state</li>
                </ul>
            </p>

            <p>
                You might show a loading state, and update the error state when the API call fails. In some cases, you might accidentally set loading state and error state at the same time.
                This is a common problem, and it is very easy to fall into. UI is stuck in a loading state, and the user is not sure if the form has been submitted or not. It can also result in worse
                cases where the form fails, but you already set the success state. So, you have the famous 
                
                
            <blockquote>
                   "Your submission failed successfully!"
            </blockquote>
            </p>

            This can lead to increased UX issues and at worse, your app might actually lose money.

            <h2>Enter State Machines</h2>

            <p>
                State machines provide a mathematical model for computation, where your application can be in exactly 
                one of a finite number of states at any given time. This eliminates ambiguity and makes state transitions 
                explicit and predictable.
            </p>

            <p>
                With State Machines, I can define the same form with the same states as a state machine with clear states: <code>idle</code>, <code>validating</code>, 
                <code>valid</code>, <code>error</code>, <code>submitting</code>, and <code>submitted</code>. Each state has 
                specific entry conditions, exit conditions, and allowed transitions. This creates a predictable flow that's easy to reason about and debug.
            </p>

            <p>
                State Machines do many things for you, but one thing you are guaranteed is:
                <ul>
                    <li>Predictable state transitions</li>
                </ul>
            </p>

            <p>
                States are transitioned by events. For example, when the user clicks the submit button, the form will transition to the <code>submitting</code> state.
                There can not be a case where two states are active at the same time. This is because state machines are deterministic.
                Basically, as an Engineer, you are saying:

            <blockquote>
                "I have a list of states, a list of events, and a list of transitions. When the user does an event, check the current state, and based on MY own rules, transition to the next valid state."
            </blockquote>
            </p>

            <p>
                This is more powerful as we will find out later. Because essentially, if you do not handle an event at a particular state, the state machine will simply ignore any user input.
                All this sound so complicated, but it is actually pretty straight forward when you understand the basics.

                State 1 > Event 1 > State 2
            </p>

            <h2>How to implement a State Machine in React</h2>
            <p>
                State Machines are not a new concept. They have been around for a long time, and they are used in many different industries.
                The most common example is the state machine for a traffic light. It has three states: <code>red</code>, <code>yellow</code>, and <code>green</code>.
                It has three events: <code>wait</code>, <code>go</code>, and <code>stop</code>. And it has three transitions:
                <ul>
                    <li>From <code>red</code> to <code>green</code> when the timer expires</li>
                    <li>From <code>green</code> to <code>yellow</code> when the timer expires</li>
                    <li>From <code>yellow</code> to <code>red</code> when the timer expires</li>
                </ul>
            </p>

            <p>
                In Javascript, there is a library called <a href="https://stately.ai/docs/xstate">XState</a> that allows you to implement state machines. 
                And for React, there is a library called <a href="https://www.npmjs.com/package/@xstate/react">React XState</a> that allows you to implement state machines in React.
            </p>

            <h2>Conclusion</h2>

            <p>
                Boolean Hell is a real problem, and it is a problem that is only going to get worse as we use more AI. State Machines are a great way to solve this problem, and they are a great way to make your code more maintainable and predictable.
                This is already a really long article, I will be writing a follow up article on how to implement a State Machine in React with XState.
                You can follow me on LinkedIn for updates: <a href="https://www.linkedin.com/in/obafemijoseph">LinkedIn</a> where I will be sharing a Part 2 of this article.
            </p>

        </div>
    </article>
    
    <footer class="blog-footer">
        <a href="../index.html">Back to Home</a>
    </footer>
</body>
</html>